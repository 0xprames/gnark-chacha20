package chacha

import (
	"testing"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/math/uints"
	"github.com/consensys/gnark/test"
	"golang.org/x/crypto/chacha20"
)

type roundCircuit struct {
	In  [16]uints.U32
	Out [16]uints.U32 `gnark:",public"`
}

func (c *roundCircuit) Define(api frontend.API) error {
	uapi, err := uints.New[uints.U32](api)
	if err != nil {
		return err
	}

	var workingState [16]uints.U32
	copy(workingState[:], c.In[:])

	Round(uapi, &workingState)
	Serialize(uapi, &workingState)

	for i := range c.Out {
		uapi.AssertEq(c.Out[i], workingState[i])
	}

	return nil
}

type qrBlock struct {
	In  [16]uints.U32
	Out [16]uints.U32 `gnark:",public"`
}

func (c *qrBlock) Define(api frontend.API) error {
	uapi, err := uints.New[uints.U32](api)
	if err != nil {
		return err
	}

	var workingState [16]uints.U32
	copy(workingState[:], c.In[:])

	QR(uapi, &workingState, 0, 1, 2, 3)
	for i := range c.Out {
		uapi.AssertEq(c.Out[i], workingState[i])
	}
	return nil
}

/*type cipherCircuit struct {
	Key     [8]uints.U32
	Counter uints.U32
	Nonce   [3]uints.U32
	In      [16]uints.U32 `gnark:",public"`
	Out     [16]uints.U32 `gnark:",public"`
}

func (c *cipherCircuit) Define(api frontend.API) error {
	uapi, err := uints.New[uints.U32](api)
	if err != nil {
		return err
	}

	var state [16]uints.U32

	// constants
	state[0] = uints.NewU32(0x61707865)
	state[1] = uints.NewU32(0x3320646e)
	state[2] = uints.NewU32(0x79622d32)
	state[3] = uints.NewU32(0x6b206574)

	// set key
	copy(state[4:], c.Key[:])
	state[12] = c.Counter
	copy(state[13:], c.Nonce[:])

	Round(uapi, &state)
	Serialize(uapi, &state)

	var ciphertext [16]uints.U32
	for i, b := range state {
		ciphertext[i] = uapi.Xor(c.In[i], b)
	}

	for i := range c.Out {
		uapi.AssertEq(c.Out[i], ciphertext[i])
	}

	return nil
}*/

func TestQR(t *testing.T) {
	assert := test.NewAssert(t)
	witness := qrBlock{}
	witness.In[0] = uints.NewU32(0x11111111)
	witness.In[1] = uints.NewU32(0x01020304)
	witness.In[2] = uints.NewU32(0x9b8d6f43)
	witness.In[3] = uints.NewU32(0x01234567)

	witness.Out[0] = uints.NewU32(0xea2a92f4)
	witness.Out[1] = uints.NewU32(0xcb1cf8ce)
	witness.Out[2] = uints.NewU32(0x4581472e)
	witness.Out[3] = uints.NewU32(0x5881c4bb)

	err := test.IsSolved(&qrBlock{}, &witness, ecc.BN254.ScalarField())
	assert.NoError(err)

	assert.CheckCircuit(&qrBlock{}, test.WithCurves(ecc.BN254))

}

func TestBlockGeneric(t *testing.T) {
	assert := test.NewAssert(t)

	in := uints.NewU32Array([]uint32{
		0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
		0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,
		0x00000001, 0x09000000, 0x4a000000, 0x00000000})

	out := BytesToUint32BE([]uint8{
		0x10, 0xf1, 0xe7, 0xe4, 0xd1, 0x3b, 0x59, 0x15, 0x50, 0x0f, 0xdd, 0x1f, 0xa3, 0x20, 0x71, 0xc4,
		0xc7, 0xd1, 0xf4, 0xc7, 0x33, 0xc0, 0x68, 0x03, 0x04, 0x22, 0xaa, 0x9a, 0xc3, 0xd4, 0x6c, 0x4e,
		0xd2, 0x82, 0x64, 0x46, 0x07, 0x9f, 0xaa, 0x09, 0x14, 0xc2, 0xd7, 0x05, 0xd9, 0x8b, 0x02, 0xa2,
		0xb5, 0x12, 0x9c, 0xd1, 0xde, 0x16, 0x4e, 0xb9, 0xcb, 0xd0, 0x83, 0xe8, 0xa2, 0x50, 0x3c, 0x4e})

	witness := roundCircuit{}
	copy(witness.In[:], in)
	copy(witness.Out[:], out)
	err := test.IsSolved(&roundCircuit{}, &witness, ecc.BN254.ScalarField())
	assert.NoError(err)

	assert.CheckCircuit(&roundCircuit{}, test.WithCurves(ecc.BN254))
}

func TestCipher(t *testing.T) {
	assert := test.NewAssert(t)

	bKey := []uint8{
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}

	bNonce := []uint8{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x00}

	counter := uints.NewU32(1)

	bPt := []uint8{
		0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c,
		0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73,
		0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x49, 0x20, 0x63,
		0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f,
		0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20,
		0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73,
		0x63, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69,
		0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c,
	}

	bCt := []uint8{
		0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d, 0x69, 0x81,
		0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc, 0xfd, 0x9f, 0xae, 0x0b,
		0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59, 0x3d, 0xab, 0xcd, 0x62, 0xb3, 0x57,
		0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab, 0x8f, 0x53, 0x0c, 0x35, 0x9f, 0x08, 0x61, 0xd8,
		0x07, 0xca, 0x0d, 0xbf, 0x50, 0x0d, 0x6a, 0x61, 0x56, 0xa3, 0x8e, 0x08, 0x8a, 0x22, 0xb6, 0x5e,
		0x52, 0xbc, 0x51, 0x4d, 0x16, 0xcc, 0xf8, 0x06, 0x81, 0x8c, 0xe9, 0x1a, 0xb7, 0x79, 0x37, 0x36,
		0x5a, 0xf9, 0x0b, 0xbf, 0x74, 0xa3, 0x5b, 0xe6, 0xb4, 0x0b, 0x8e, 0xed, 0xf2, 0x78, 0x5e, 0x42,
		0xbf, 0x02, 0x10, 0x6a, 0x16, 0x53, 0x3a, 0xc0, 0xe6, 0x9f, 0x9c, 0xaf, 0x5c, 0xff, 0xb0, 0x81,
	}

	plaintext := BytesToUint32BE(bPt)

	ciphertext := BytesToUint32BE(bCt)

	ct := make([]byte, 128)

	cipher, err := chacha20.NewUnauthenticatedCipher(bKey, bNonce)
	assert.NoError(err)

	cipher.SetCounter(1)
	cipher.XORKeyStream(ct, bPt)

	witness := Circuit{}
	copy(witness.Key[:], BytesToUint32LE(bKey))
	copy(witness.Nonce[:], BytesToUint32LE(bNonce))
	witness.Counter = counter
	copy(witness.In[:], plaintext)
	copy(witness.Out[:], ciphertext)

	err = test.IsSolved(&Circuit{}, &witness, ecc.BN254.ScalarField())
	assert.NoError(err)

	assert.CheckCircuit(&Circuit{}, test.WithCurves(ecc.BN254))
}
